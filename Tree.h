#include "main.h"

#define TSTRING(x) std::array<TCHAR, x>
#define PARENT(i) (i - 1) / 2
#define LEFT_CHILD(i) 2 * i + 1
#define RIGHT_CHILD(i) 2 * i + 2

ENUM CLASS ALGO_STATES : INT{ UNTOUCHED, PENDING, DONE, ALGO_STATES_CNT = 3 };

TYPEDEF STRUCT LEAF{
	UINT ID = NULL;
	TCHAR tSymbol[20] = {};
	TCHAR tFPValue[20] = {};
	DOUBLE FPValue = NULL;
	/* WYCOFANE Z U¯YTKU (patrz 
	ALGO_STATES State = ALGO_STATES::UNTOUCHED;
	*/
	STRUCT LEAF* LeftChild = nullptr;
	STRUCT LEAF* RightChild = nullptr;
	// BOOL bAutoGenerated = FALSE;
} LEAF, *LPLEAF;

// wartoœci sta³e i nie dobrego powodu, ¿eby je drastycznie zwiêkszaæ
constexpr UINT SLength = sizeof(LEAF::tSymbol) / sizeof(TCHAR);
constexpr UINT FPLength = sizeof(LEAF::tFPValue) / sizeof(TCHAR);
// wymiary prostok¹tów rysowania elips (?)
constexpr CONST UINT RECT_WIDTH = 100;
constexpr CONST UINT RECT_HEIGHT = 50;

TYPEDEF STRUCT TreeProperties{
	UINT cxInnerLeafWidth = 0;
	UINT cxTotalLeafWidth = 0;
	UINT cxTreeWidth = 0;
	UINT cNestLevels = 0;
	UINT cLeaves = 0;
	UINT cyTotalLeafHeight = RECT_HEIGHT;
} TREEPROPERTIES, *LPTREEPROPERTIES;

TYPEDEF UNION {
	TREEPROPERTIES TreeProps;
	DRAWTEXTPARAMS DTParams;
} TREEPROPERTIESEX, *LPTREEPROPERTIESEX;

// szablony stringów porównañ
constexpr CONST TCHAR* COMPARE_STRING_FLOAT = L"%f\0";
constexpr CONST TCHAR* COMPARE_STRING_DOUBLE = L"%lf\0";
constexpr CONST TCHAR* COMPARE_STRING_LONG_DOUBLE = L"%Lf\0";
constexpr CONST TCHAR* COMPARE_STRING_STRING = L"%s\0";
constexpr CONST TCHAR* COMPARE_STRING_LONG = L"%ld\0";
constexpr CONST TCHAR* COMPARE_STRING_LONG_LONG = L"%lld\0";
constexpr CONST TCHAR* COMPARE_STRING_CHAR = L"%c\0";
constexpr CONST TCHAR* COMPARE_STRING_INT = L"%d\0";
constexpr CONST TCHAR* COMPARE_STRING_UINT = L"%u\0";	// tak, ale nie - bez dodatkowego formatowania zwraca liczbê U2
constexpr CONST TCHAR* COMPARE_STRING_DEFAULT = COMPARE_STRING_INT;


// przyk³adowe drzewo
STATIC STRUCT LEAF DefaultTreeValues[] = {
	{9, TEXT("i"), TEXT("0.04"), 0.04, /*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr},
	{8, TEXT("h"), TEXT("0.06"), 0.06, /*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr},
	{7, TEXT("g"), TEXT("0.08"), 0.08, /*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr},
	{6, TEXT("f"), TEXT("0.1 "), 0.1 , /*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr},
	{5, TEXT("e"), TEXT("0.1 "), 0.1 , /*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr},
	{4, TEXT("d"), TEXT("0.12"), 0.12, /*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr},
	{3, TEXT("c"), TEXT("0.15"), 0.15, /*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr},
	{2, TEXT("b"), TEXT("0.15"), 0.15, /*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr},
	{1, TEXT("a"), TEXT("0.2 "), 0.2 , /*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr}
};

STATIC CONST INT cDefaultValues = sizeof(DefaultTreeValues) / sizeof(DefaultTreeValues[0]);

// Nie ma dobrego sposobu, ¿eby przeliczyæ iloœæ elementów w enum (class).
// Wa¿ne: przy zmianie iloœci elementów zmieniæ wartoœæ ostatniego elementu!
ENUM CLASS WORK_MODE : BOOL{ PROBABILITY, FREQUENCY, WORK_MODE_CNT = 2 };
ENUM CLASS COLUMNS : INT{ ID = 0, SYMBOL, VALUE, COLUMNS_CNT = 3 };
ENUM CLASS CONFLICTS : INT{ ID, SYMBOL, PROB_VALUE, PROB_SUM, CONFLICTS_CNT = 4 };
constexpr UINT CONFLICTS_STRING_ID[static_cast<INT>(CONFLICTS::CONFLICTS_CNT)] = {IDS_TREE_ID_ERROR, IDS_TREE_SYMBOL_ERROR,
										IDS_TREE_PROB_SUM_ERROR, IDS_TREE_PROB_VALUE_ERROR};


// krótsza sk³adnia
typedef std::array<BOOL, static_cast<INT>(CONFLICTS::CONFLICTS_CNT)> ConflictsArray;

// funkcje u¿ywane w drzewko.cpp

INT_PTR TreeDialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL AddListHeaders(HWND);
BOOL InsertListItem(HWND, STRUCT LEAF&);
LRESULT CALLBACK AuxiliaryEditProc(INT, WPARAM, LPARAM);
VOID HandleConflicts(ConflictsArray&, HWND);
VOID GenerateTree(LEAF_VECTOR&, HWND, UINT);
LEAF PrepareTree(LEAF_VECTOR&);
VOID DrawTree(LEAF&, HWND, TREEPROPERTIES&);
BOOL CompareFPValues(const LEAF, const LEAF);
RECT CreateRect(POINT, INT, INT);
POINT CenterDown(RECT);
POINT CenterDown(LPRECT);
VOID DrawLeaf(HWND, PPOINT, LEAF&, UINT, BOOL,DRAWTEXTPARAMS&, TREEPROPERTIES&, HDC);
TREEPROPERTIES CreateTreeProperties(LEAF&, UINT, HWND);


// Weryfikuj podane dane
// przyjmuje: dane do weryfikacji, ich d³ugoœæ, ci¹g znaków jako klucz/katalizator

// ============================================================
// UWAGA: trzeba póŸniej delete[] adres zwracany przez funkcjê!
// ============================================================

TEMPLATE <TYPENAME T>
STATIC PTCHAR VerifyInput(HWND hwnd, PTCHAR stringToValidate, UINT stringLength, CONST TCHAR* compareString) {
	
	T t = NULL;
	// dopasuj do ¿¹danego typu
	if (!std::is_same<T, PTCHAR>::value) {
		PTCHAR bufor = new TCHAR[stringLength]{};
		if (swscanf_s(stringToValidate, compareString, &t, stringLength) != 1) {
			delete[] bufor;
			return nullptr;
		}
		if (std::is_floating_point<T>::value) {
			// od C++20 istnieje bit_cast<T>(t), który robi dok³adnie to samo
			if (std::isnan(*(DOUBLE*)(VOID*)(&t)) || std::isinf(*(DOUBLE*)(VOID*)(&t))) { 
				delete[] bufor;
				return nullptr;
			}
		}
		if (_snwprintf_s(bufor, stringLength, _TRUNCATE, compareString, t) <= 0) {
			delete[] bufor;
			return nullptr;
		}
		return bufor;
	} else {
		if (lstrlen(stringToValidate) != 0) {
			return stringToValidate;
		}
		return nullptr;
	}
	
};

// Rozszerzona funkcja; weryfikuj i wstaw
// Uwaga: nale¿y podaæ HWND do pola tekstowego, nie do listy, w której jest!
TEMPLATE<TYPENAME CompareType>
BOOL VerifyAndProcessInput(HWND hEdit,
	PTCHAR stringToValidate,
	LVHITTESTINFO& lvthi,
	UINT stringLength = 10,
	CONST TCHAR* compareString = COMPARE_STRING_DEFAULT) {

	// weryfikuj
	PTCHAR cleanInput = VerifyInput<CompareType>(hEdit, stringToValidate, stringLength, compareString);
	if (cleanInput == nullptr)
		return FALSE;


	// zmieñ wartoœæ listy
	HWND hList = GetParent(hEdit);
	if (hList == NULL) return FALSE;
	ListView_SetItemText(hList, lvthi.iItem, lvthi.iSubItem, cleanInput);
	if (compareString != COMPARE_STRING_STRING)
		delete[] cleanInput; // nie lubimy wycieków

	// przetwórz now¹ listê
	// co nale¿y sprawdziæ:
	// kolumna 0: konflikt l.p.
	// kolumna 1: konflikt symboli
	// kolumna 2: Ÿle znormalizowane prawdopodobieñstwo/ujemne prawd.

	ConflictsArray conflicts = {};

	UINT cCols = ListView_GetItemCount(hList);
	switch (lvthi.iSubItem) {
	case static_cast<INT>(COLUMNS::ID): {
		std::set<UINT> sIDs;
		TSTRING(20) bufor = {};
		for (SIZE_T iCol = 0; iCol < cCols; iCol++) {
			ListView_GetItemText(hList, iCol, lvthi.iSubItem, bufor.data(), 20);
			UINT uID;
			_snwscanf_s(bufor.data(), 20, COMPARE_STRING_UINT, &uID);
			if(!(sIDs.insert(uID)).second){
#if defined DEBUG
				MessageBox(NULL, TEXT("konflikt interesów: ID"), TEXT("title"), MB_OK);
#endif
				conflicts[static_cast<INT>(CONFLICTS::ID)] = TRUE;
				break;
			}
		}

		break;
	}
	case static_cast<INT>(COLUMNS::SYMBOL): {
		std::set<TSTRING(SLength)> sIDs;
		TSTRING(SLength) bufor = {};
		for (SIZE_T iCol = 0; iCol < cCols; iCol++) {
			ListView_GetItemText(hList, iCol, lvthi.iSubItem, bufor.data(), SLength);
			if (!(sIDs.insert(bufor)).second) {
#if defined DEBUG
				MessageBox(NULL, TEXT("konflikt interesów: symbole"), TEXT("title"), MB_OK);
#endif
				conflicts[static_cast<INT>(CONFLICTS::SYMBOL)] = TRUE;
				break;
			}
		}
		break;
	}
	default: {
		DOUBLE dAccumulator = 0;
		DOUBLE dValue = 0;
		std::array<TCHAR, FPLength> psBuffer = {};
		for (SIZE_T iCol = 0; iCol < cCols; iCol++) {
			ListView_GetItemText(hList, iCol, lvthi.iSubItem, psBuffer.data(), SLength);
			// weryfikacja ju¿ by³a wczeœniej, wiêc mi wolno (?)
			dValue = _wtof(psBuffer.data());
			if (dValue <= 0) {
				conflicts[static_cast<INT>( CONFLICTS::PROB_VALUE)] = TRUE;
				break;
			}
			dAccumulator += dValue;
		}
		if (dAccumulator != 1) {
			conflicts[static_cast<INT>(CONFLICTS::PROB_SUM)] = TRUE;
			break;
		}
	}
	}
	HandleConflicts(conflicts, GetGrandParent(hEdit));
	return TRUE;
}
