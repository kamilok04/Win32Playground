#include "main.h"

#define TSTRING(x) std::array<TCHAR, x>
#define PARENT(i) (i - 1) / 2
#define LEFT_CHILD(i) 2 * i + 1
#define RIGHT_CHILD(i) 2 * i + 2

ENUM CLASS ALGO_STATES : INT{ UNTOUCHED, PENDING, DONE, ALGO_STATES_CNT = 3 };

TYPEDEF STRUCT LEAF{
	UINT ID = NULL;
//TCHAR tSymbol[20] = {};
std::wstring tSymbol = {};
//TCHAR tFPValue[20] = {};
//std::array<TCHAR, 20> tFPValue = {};
std::wstring tFPValue = {};
DOUBLE FPValue = 0;
UINT FFValue = 0;
STRUCT LEAF* LeftChild = nullptr;
STRUCT LEAF* RightChild = nullptr;
// BOOL bAutoGenerated = FALSE;
} LEAF, * LPLEAF;

// wartoœci sta³e i nie dobrego powodu, ¿eby je drastycznie zwiêkszaæ
constexpr UINT SLength = sizeof(LEAF::tSymbol) / sizeof(TCHAR);
constexpr UINT FPLength = sizeof(LEAF::tFPValue) / sizeof(TCHAR);
// wymiary prostok¹tów rysowania elips (?)
constexpr CONST UINT RECT_WIDTH = 100;
constexpr CONST UINT RECT_HEIGHT = 50;

TYPEDEF STRUCT TreeProperties{
	UINT cxInnerLeafWidth = 0;
	UINT cxTotalLeafWidth = 0;
	UINT cxTreeWidth = 0;
	UINT cNestLevels = 0;
	UINT cLeaves = 0;
	UINT cyTotalLeafHeight = RECT_HEIGHT;
	BOOL bNarrow = FALSE;
} TREEPROPERTIES, * LPTREEPROPERTIES;

TYPEDEF UNION{
	TREEPROPERTIES TreeProps;
	DRAWTEXTPARAMS DTParams;
} TREEPROPERTIESEX, * LPTREEPROPERTIESEX;

// szablony stringów porównañ
constexpr CONST TCHAR* COMPARE_STRING_FLOAT = L"%f\0";
constexpr CONST TCHAR* COMPARE_STRING_DOUBLE = L"%lf\0";
constexpr CONST TCHAR* COMPARE_STRING_LONG_DOUBLE = L"%Lf\0";
constexpr CONST TCHAR* COMPARE_STRING_STRING = L"%s\0";
constexpr CONST TCHAR* COMPARE_STRING_LONG = L"%ld\0";
constexpr CONST TCHAR* COMPARE_STRING_LONG_LONG = L"%lld\0";
constexpr CONST TCHAR* COMPARE_STRING_CHAR = L"%c\0";
constexpr CONST TCHAR* COMPARE_STRING_INT = L"%d\0";
constexpr CONST TCHAR* COMPARE_STRING_UINT = L"%u\0";	// tak, ale nie - bez dodatkowego formatowania zwraca liczbê U2
constexpr CONST TCHAR* COMPARE_STRING_DEFAULT = COMPARE_STRING_INT;


// przyk³adowe drzewo
STATIC STRUCT LEAF DefaultTreeValues[] = {
	{9, TEXT("i"), TEXT("0.04"), 0.04, 0,/*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr},
	{8, TEXT("h"), TEXT("0.06"), 0.06, 0,/*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr},
	{7, TEXT("g"), TEXT("0.08"), 0.08, 0,/*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr},
	{6, TEXT("f"), TEXT("0.1 "), 0.1 , 0,/*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr},
	{5, TEXT("e"), TEXT("0.1 "), 0.1 , 0,/*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr},
	{4, TEXT("d"), TEXT("0.12"), 0.12, 0,/*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr},
	{3, TEXT("c"), TEXT("0.15"), 0.15, 0,/*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr},
	{2, TEXT("b"), TEXT("0.15"), 0.15, 0,/*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr},
	{1, TEXT("a"), TEXT("0.2 "), 0.2 , 0,/*ALGO_STATES::UNTOUCHED,*/ nullptr, nullptr}
};

STATIC CONST INT cDefaultValues = sizeof(DefaultTreeValues) / sizeof(DefaultTreeValues[0]);

// Nie ma dobrego sposobu, ¿eby przeliczyæ iloœæ elementów w enum (class).
// Wa¿ne: przy zmianie iloœci elementów zmieniæ wartoœæ ostatniego elementu!
ENUM CLASS WORK_MODE : BOOL{ PROBABILITY, FREQUENCY, WORK_AUTO, WORK_MODE_MAX = 3 };
ENUM CLASS COLUMNS : INT{ ID = 0, SYMBOL, VALUE, COLUMNS_CNT = 3 };
ENUM CLASS CONFLICTS : INT{ ID, SYMBOL, PROB_VALUE, PROB_SUM, CONFLICTS_CNT = 4 };
constexpr UINT CONFLICTS_STRING_ID[static_cast<INT>(CONFLICTS::CONFLICTS_CNT)] = { IDS_TREE_ID_ERROR, IDS_TREE_SYMBOL_ERROR,
										IDS_TREE_PROB_SUM_ERROR, IDS_TREE_PROB_VALUE_ERROR };


// krótsza sk³adnia
typedef std::array<BOOL, static_cast<INT>(CONFLICTS::CONFLICTS_CNT)> ConflictsArray;

// funkcje u¿ywane w drzewko.cpp

INT_PTR TreeDialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL AddListHeaders(HWND);
BOOL InsertListItem(HWND, STRUCT LEAF&);
LRESULT CALLBACK AuxiliaryEditProc(INT, WPARAM, LPARAM);
BOOL HandleConflicts(ConflictsArray&, HWND);
VOID GenerateTree(LEAF_VECTOR&, HWND, UINT);
LEAF PrepareTree(LEAF_VECTOR&);
VOID DrawTree(LEAF&, HWND, TREEPROPERTIES&);
BOOL CompareFPValues(const LEAF, const LEAF);
RECT CreateRect(POINT, INT, INT);
POINT CenterDown(RECT);
POINT CenterDown(LPRECT);
VOID DrawLeaf(HWND, PPOINT, LEAF&, UINT, BOOL, DRAWTEXTPARAMS&, TREEPROPERTIES&, HDC, BOOL);
TREEPROPERTIES CreateTreeProperties(LEAF&, UINT, HWND);
LEAF_VECTOR CreateTreeFromList(HWND hList);
LEAF_VECTOR ProcessAutoText(PTCHAR);
// Weryfikuj podane dane
// przyjmuje: dane do weryfikacji, ich d³ugoœæ, ci¹g znaków jako klucz/katalizator

// ============================================================
// UWAGA: trzeba póŸniej delete[] adres zwracany przez funkcjê!
// ============================================================

TEMPLATE <TYPENAME T>
STATIC PTCHAR VerifyInput(HWND hwnd, PTCHAR stringToValidate, UINT stringLength, CONST TCHAR* compareString) {

	T t = NULL;
	// dopasuj do ¿¹danego typu
	if (!std::is_same<T, PTCHAR>::value) {
		PTCHAR bufor = new TCHAR[stringLength]{};
		if (swscanf_s(stringToValidate, compareString, &t, stringLength) != 1) {
			delete[] bufor;
			return nullptr;
		}
		if (std::is_floating_point<T>::value) {
			// od C++20 istnieje bit_cast<T>(t), który robi dok³adnie to samo
			DOUBLE dValue = _wtof(stringToValidate);
			if (std::isnan(dValue) || std::isinf(dValue)) {

				delete[] bufor;
				return nullptr;
			}
			_snwprintf_s(bufor, stringLength, _TRUNCATE, L"%.2f", dValue);
			return bufor;
		}
		if (_snwprintf_s(bufor, stringLength, _TRUNCATE, compareString, t) <= 0) {
			delete[] bufor;
			return nullptr;
		}
		return bufor;
	}
	else {
		if (lstrlen(stringToValidate) != 0) {
			return stringToValidate;
		}
		return nullptr;
	}

};

// Rozszerzona funkcja; weryfikuj i wstaw
// Uwaga: nale¿y podaæ HWND do pola tekstowego, nie do listy, w której jest!
TEMPLATE<TYPENAME CompareType>
BOOL VerifyAndProcessInput(HWND hEdit,
	PTCHAR stringToValidate,
	LVHITTESTINFO& lvthi,
	LEAF_VECTOR& lv,
	UINT stringLength = 10,
	CONST TCHAR* compareString = COMPARE_STRING_DEFAULT,
	WORK_MODE workMode = WORK_MODE::PROBABILITY) {

	// weryfikuj
	PTCHAR cleanInput = VerifyInput<CompareType>(hEdit, stringToValidate, stringLength, compareString);
	if (cleanInput == nullptr)
		return FALSE;


	// zmieñ wartoœæ listy
	HWND hList = GetParent(hEdit);
	if (hList == NULL) return FALSE;
	ListView_SetItemText(hList, lvthi.iItem, lvthi.iSubItem, cleanInput);

	// przetwórz now¹ listê
	// i wpisz wartoœæ do drzewa
	// co nale¿y sprawdziæ:
	// kolumna 0: konflikt l.p.
	// kolumna 1: konflikt symboli
	// kolumna 2: Ÿle znormalizowane prawdopodobieñstwo/ujemne prawd.

	ConflictsArray conflicts = {};

	UINT cCols = ListView_GetItemCount(hList);
	switch (lvthi.iSubItem) {
	case static_cast<INT>(COLUMNS::ID): {
		std::set<UINT> sIDs;
		TSTRING(20) bufor = {};
		for (SIZE_T iCol = 0; iCol < cCols; iCol++) {
			ListView_GetItemText(hList, iCol, lvthi.iSubItem, bufor.data(), 20);
			UINT uID;
			_snwscanf_s(bufor.data(), 20, COMPARE_STRING_UINT, &uID);
			if (!(sIDs.insert(uID)).second) {
#if defined DEBUG
				MessageBox(NULL, TEXT("konflikt interesów: ID"), TEXT("title"), MB_OK);
#endif
				conflicts[static_cast<INT>(CONFLICTS::ID)] = TRUE;
				break;
			}
		}
		break;
	}
	case static_cast<INT>(COLUMNS::SYMBOL): {
		std::set<TSTRING(SLength)> sIDs;
		TSTRING(SLength) bufor = {};
		for (SIZE_T iCol = 0; iCol < cCols; iCol++) {
			ListView_GetItemText(hList, iCol, lvthi.iSubItem, bufor.data(), SLength);
			if (!(sIDs.insert(bufor)).second) {
#if defined DEBUG
				MessageBox(NULL, TEXT("konflikt interesów: symbole"), TEXT("title"), MB_OK);
#endif
				conflicts[static_cast<INT>(CONFLICTS::SYMBOL)] = TRUE;
				break;
			}
		}
		break;
	}
	default: {
		switch (workMode) {
		case WORK_MODE::PROBABILITY: {
			DOUBLE dAccumulator = 0;
			DOUBLE dValue = 0;
			std::array<TCHAR, FPLength> psBuffer = {};
			for (SIZE_T iCol = 0; iCol < cCols; iCol++) {
				ListView_GetItemText(hList, iCol, lvthi.iSubItem, psBuffer.data(), SLength);
				// weryfikacja ju¿ by³a wczeœniej, wiêc mi wolno (?)
				dValue = _wtof(psBuffer.data());
				if (dValue <= 0) {
					conflicts[static_cast<INT>(CONFLICTS::PROB_VALUE)] = TRUE;
					break;
				}
				dAccumulator += dValue;
			}
			if (dAccumulator != 1) {
				conflicts[static_cast<INT>(CONFLICTS::PROB_SUM)] = TRUE;
				break;
			}
		}

		case WORK_MODE::FREQUENCY: {
			UINT uSumOfFreq = 0;
			UINT cCols = ListView_GetItemCount(hList);
			for (UINT iCol = 0; iCol < cCols; iCol++) {
				TSTRING(20) bufor = {};
				ListView_GetItemText(hList, iCol, lvthi.iSubItem, bufor.data(), 20);
				UINT uFreq;
				_snwscanf_s(bufor.data(), 20, COMPARE_STRING_UINT, &uFreq);
				uSumOfFreq += uFreq;
			}}
		}
	}
		   if (compareString != COMPARE_STRING_STRING)
			   delete[] cleanInput;
		   
		   break;
	}
		HandleConflicts(conflicts, GetGrandParent(hEdit));
		   return TRUE;
	}
